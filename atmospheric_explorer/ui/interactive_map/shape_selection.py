"""\
Module to manage selections done on the folium map.
"""
from __future__ import annotations

import geopandas as gpd
import streamlit as st
from shapely.geometry import shape
from shapely.ops import unary_union

from atmospheric_explorer.loggers import get_logger
from atmospheric_explorer.shapefile import ShapefilesDownloader

logger = get_logger("atmexp")


@st.cache_data(show_spinner="Fetching shapefile...")
def shapefile_dataframe() -> gpd.GeoDataFrame:
    """Get and cache the shapefile"""
    return (
        ShapefilesDownloader()
        .get_as_dataframe()
        .rename({"ADMIN": "label"}, axis=1)[["label", "geometry"]]
    )


class ShapeSelection:
    """Class to manage different possible selection on the interactive map."""

    _crs = "EPSG:4326"

    def __init__(self, dataframe: gpd.GeoDataFrame, is_country: bool):
        self.dataframe = dataframe
        self.is_countries_poly = is_country

    def __repr__(self) -> str:
        return repr(self.dataframe)

    @property
    def labels(self) -> list[str]:
        """Selection labels, useful when countries are selected."""
        return self.dataframe["label"].unique()

    @staticmethod
    def get_event_label(out_event) -> str | None:
        """Get label from folium map click event"""
        if out_event.get("last_active_drawing") is not None:
            if out_event["last_active_drawing"].get("properties") is not None:
                return out_event["last_active_drawing"]["properties"].get("label")
        return None

    @classmethod
    def from_out_event(cls, out_event) -> ShapeSelection:
        """Generate a ShapeSelection object from an output event generated by streamlit_folium."""
        admin = cls.get_event_label(out_event)
        return cls(
            dataframe=gpd.GeoDataFrame(
                {
                    "label": [admin] if admin is not None else ["generic shape"],
                    "geometry": [shape(out_event["last_active_drawing"]["geometry"])],
                },
                crs=cls._crs,
            ),
            is_country=(admin is not None),
        )

    @classmethod
    def from_countries_list(cls, countries: list[str]) -> ShapeSelection:
        """Generate a ShapeSelection object from a list of countries, shapes are taken from the shapefile."""
        sh_df = shapefile_dataframe()
        sh_df = sh_df[sh_df["label"].isin(countries)]
        return cls(dataframe=sh_df, is_country=True)

    def __eq__(self, other: ShapeSelection) -> bool:
        return self.dataframe.equals(other.dataframe)

    @classmethod
    def countries_from_shape(cls, shape_selection: ShapeSelection) -> ShapeSelection:
        """\
        Generate a ShapeSelection object encompassing countries that are touched by the shape_selection objects passed.
        """
        if shape_selection.is_countries_poly:
            return shape_selection
        shapefile = shapefile_dataframe()
        selected_geometry = unary_union(shape_selection.dataframe["geometry"])
        return cls(
            dataframe=(
                shapefile[
                    ~selected_geometry.intersection(shapefile["geometry"]).is_empty
                ].reset_index(drop=True)
            ),
            is_country=True,
        )
